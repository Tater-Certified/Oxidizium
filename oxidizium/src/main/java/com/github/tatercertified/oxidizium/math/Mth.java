package com.github.tatercertified.oxidizium.math;

import com.github.tatercertified.oxidizium.utils.annotation.*;

public interface Mth {
    float sin(double value);
    float cos(double value);
    float sin(float value);
    float cos(float value);
    float sqrt(@PositiveOnly float value);
    int floor(float value);
    int floor(double value);
    long lfloor(double value);
    float abs(float value);
    int abs(int value);
    int ceil(float value);
    int ceil(double value);
    int clamp(int value, @Min int min, @Max int max);
    long clamp(long value, @Min long min, @Max long max);
    float clamp(float value, @Min float min, @Max float max);
    double clamp(double value, @Min double min, @Max double max);
    double clampedLerp(double delta, double start, double end);
    float clampedLerp(float delta, float start, float end);
    int method_76800(int i, int j);
    float method_76799(float f, float g);
    int method_76801(int i, int j, int k, int l);
    double absMax(double a, double b);
    int floorDiv(int dividend, @NonZero int divisor);
    boolean approximatelyEquals(float a, float b);
    boolean approximatelyEquals(double a, double b);
    int floorMod(int dividend, @NonZero int divisor);
    float floorMod(float dividend, @NonZero float divisor);
    double floorMod(double dividend, @NonZero double divisor);
    boolean isMultipleOf(int a, @NonZero int b);
    byte packDegrees(float degrees);
    float unpackDegrees(byte packedDegrees);
    int wrapDegrees(int degrees);
    float wrapDegrees(long degrees);
    float wrapDegrees(float degrees);
    double wrapDegrees(double degrees);
    float subtractAngles(float start, float end);
    float angleBetween(float first, float second);
    float clampAngle(float value, float mean, float delta);
    float stepTowards(float from, float to, float step);
    float stepUnwrappedAngleTowards(float from, float to, float step);
    int parseInt(String string, int fallback);
    int smallestEncompassingPowerOfTwo(int value);
    int smallestEncompassingSquareSideLength(@PositiveOnly int value);
    boolean isPowerOfTwo(int value);
    int ceilLog2(int value);
    int floorLog2(int value);
    int packRgb(float r, float g, float b);
    long ceilLong(double value);
    float fractionalPart(float value);
    double fractionalPart(double value);
    long hashCode(int x, int y, int z);
    double getLerpProgress(double value, double start, double end);
    float getLerpProgress(float value, float start, float end);
    double atan2(double y, double x);
    float inverseSqrt(@Bounded(minInclusive = 1, maxExclusive = 100) float x);
    double inverseSqrt(@Bounded(minInclusive = 1, maxExclusive = 100) double x);
    double fastInverseSqrt(double x);
    float fastInverseCbrt(float x);
    int hsvToRgb(@PositiveOnly float hue, @PositiveOnly float saturation, @PositiveOnly float value);
    int hsvToArgb(@PositiveOnly float hue, @PositiveOnly float saturation, @PositiveOnly float value, @PositiveOnly int alpha);
    int idealHash(int value);
    int lerp(float delta, int start, int end);
    int lerpPositive(float delta, int start, int end);
    float lerp(float delta, float start, float end);
    double lerp(double delta, double start, double end);
    double lerp2(double deltaX, double deltaY, double x0y0, double x1y0, double x0y1, double x1y1);
    double lerp3(double deltaX, double deltaY, double deltaZ, double x0y0z0, double x1y0z0, double x0y1z0, double x1y1z0, double x0y0z1, double x1y0z1, double x0y1z1, double x1y1z1);
    float catmullRom(float delta, float p0, float p1, float p2, float p3);
    double perlinFade(double value);
    double perlinFadeDerivative(double value);
    int sign(double value);
    float lerpAngleDegrees(float delta, float start, float end);
    double lerpAngleDegrees(double delta, double start, double end);
    float lerpAngleRadians(float delta, float start, float end);
    float wrap(float value, float maxDeviation);
    float square(float n);
    double square(double n);
    int square(int n);
    long square(long n);
    double clampedMap(double value, double oldStart, double oldEnd, double newStart, double newEnd);
    float clampedMap(float value, float oldStart, float oldEnd, float newStart, float newEnd);
    double map(double value, double oldStart, double oldEnd, double newStart, double newEnd);
    float map(float value, float oldStart, float oldEnd, float newStart, float newEnd);
    int roundUpToMultiple(int value, @NonZero int divisor);
    int ceilDiv(int a, @NonZero int b);
    double squaredHypot(double a, double b);
    double hypot(double a, double b);
    float hypot(float a, float b);
    double squaredMagnitude(double a, double b, double c);
    double magnitude(double a, double b, double c);
    float magnitude(float a, float b, float c);
    int roundDownToMultiple(double a, int b);
    int multiplyFraction(int numerator, int denominator, int multiplier);
    float lithiumSin(double value);
    float lithiumCos(double value);
    float lithiumSin(float value);
    float lithiumCos(float value);
}
